// Package candidvalue is autogenerated by https://github.com/0x51-dev/upeg. DO NOT EDIT.
package candidvalue

import (
	"github.com/0x51-dev/upeg/parser"
	"github.com/0x51-dev/upeg/parser/op"
)

var (
	Values       = op.Capture{Name: "Values", Value: op.Or{op.And{'(', Sp, op.Optional{Value: op.And{Value, op.ZeroOrMore{Value: op.And{Sp, ',', Sp, Value}}}}, Sp, ')'}, Value}}
	Value        = op.Or{OptValue, Num, Bool, Null, Text, Record, Variant, Principal, Vec, Blob}
	OptValue     = op.Capture{Name: "OptValue", Value: op.And{"opt", Spp, op.Or{Num, Bool, Null, Text, Record, Variant, Principal, Vec, Blob}}}
	Num          = op.Capture{Name: "Num", Value: op.And{NumValue, op.Optional{Value: op.And{Sp, ':', Sp, NumType}}}}
	NumValue     = op.Capture{Name: "NumValue", Value: op.And{op.Optional{Value: '-'}, Digit, op.ZeroOrMore{Value: op.And{op.Optional{Value: '_'}, Digit}}, op.Optional{Value: op.And{'.', Digit, op.ZeroOrMore{Value: op.And{op.Optional{Value: '_'}, Digit}}}}}}
	NumType      = op.Capture{Name: "NumType", Value: op.Or{"nat8", "nat16", "nat32", "nat64", "nat", "int8", "int16", "int32", "int64", "int", "float32", "float64"}}
	Bool         = op.And{BoolValue, op.Optional{Value: op.And{Sp, ':', Sp, "bool"}}}
	BoolValue    = op.Capture{Name: "BoolValue", Value: op.Or{"true", "false"}}
	Blob         = op.Capture{Name: "Blob", Value: op.And{"blob", Spp, rune(0x22), op.ZeroOrMore{Value: op.Repeat{Min: 2, Max: 2, Value: Hex}}, rune(0x22)}}
	Null         = op.Capture{Name: "Null", Value: "null"}
	Principal    = op.Capture{Name: "Principal", Value: op.And{"principal", Spp, TextValue}}
	Text         = op.Capture{Name: "Text", Value: op.And{TextValue, op.Optional{Value: op.And{Sp, ':', Sp, "text"}}}}
	TextValue    = op.Capture{Name: "TextValue", Value: op.And{rune(0x22), op.ZeroOrMore{Value: Char}, rune(0x22)}}
	Record       = op.Capture{Name: "Record", Value: op.And{"record", Sp, '{', Ws, op.Optional{Value: RecordFields}, Ws, '}'}}
	RecordFields = op.And{RecordField, Sp, op.ZeroOrMore{Value: op.And{';', Ws, RecordField, Sp}}, op.Optional{Value: ';'}}
	RecordField  = op.Capture{Name: "RecordField", Value: op.And{Id, Sp, '=', Sp, op.Reference{Name: "Value"}}}
	Variant      = op.Capture{Name: "Variant", Value: op.And{"variant", Sp, '{', Ws, VariantField, Ws, '}'}}
	VariantField = op.And{Id, op.Optional{Value: op.And{Sp, '=', Sp, op.Reference{Name: "Value"}}}, op.Optional{Value: ';'}}
	Vec          = op.Capture{Name: "Vec", Value: op.And{"vec", Sp, '{', Ws, op.Optional{Value: VecFields}, Ws, '}'}}
	VecFields    = op.And{op.Reference{Name: "Value"}, Sp, op.ZeroOrMore{Value: op.And{';', Ws, op.Reference{Name: "Value"}, Sp}}, op.Optional{Value: ';'}}
	Id           = op.Capture{Name: "Id", Value: op.And{op.Or{Letter, '_'}, op.ZeroOrMore{Value: op.Or{Letter, Digit, '_'}}}}
	Sp           = op.ZeroOrMore{Value: ' '}
	Spp          = op.And{' ', Sp}
	Ws           = op.ZeroOrMore{Value: op.Or{' ', rune(0x09), rune(0x0A), op.And{rune(0x0D), rune(0x0A)}, rune(0x0D)}}
	Char         = op.Or{Utf, op.And{ESC, op.Repeat{Min: 2, Max: 2, Value: Hex}}, op.And{ESC, Escape}, op.And{"\\u{", HexNum, '}'}}
	HexNum       = op.And{Hex, op.ZeroOrMore{Value: op.And{op.Optional{Value: '_'}, Hex}}}
	Utf          = op.Or{Ascii, UtfEnc}
	UtfEnc       = op.Or{op.And{op.RuneRange{Min: 0xC2, Max: 0xDF}, Utfcont}, op.And{rune(0xE0), op.RuneRange{Min: 0xA0, Max: 0xBF}, Utfcont}, op.And{rune(0xED), op.RuneRange{Min: 0x80, Max: 0x9F}, Utfcont}, op.And{op.RuneRange{Min: 0xE1, Max: 0xEC}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{op.RuneRange{Min: 0xEE, Max: 0xEF}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{rune(0xF0), op.RuneRange{Min: 0x90, Max: 0xBF}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{rune(0xF4), op.RuneRange{Min: 0x80, Max: 0x8F}, op.Repeat{Min: 2, Max: 2, Value: Utfcont}}, op.And{op.RuneRange{Min: 0xF1, Max: 0xF3}, op.Repeat{Min: 3, Max: 3, Value: Utfcont}}}
	Utfcont      = op.RuneRange{Min: 0x80, Max: 0xBF}
	Ascii        = op.Or{op.RuneRange{Min: 0x20, Max: 0x21}, op.RuneRange{Min: 0x23, Max: 0x5B}, op.RuneRange{Min: 0x5D, Max: 0x7E}}
	Escape       = op.Or{'n', 'r', 't', ESC, rune(0x22), rune(0x27)}
	Letter       = op.Or{op.RuneRange{Min: 0x41, Max: 0x5A}, op.RuneRange{Min: 0x61, Max: 0x7A}}
	Digit        = op.RuneRange{Min: 0x30, Max: 0x39}
	Hex          = op.Or{Digit, op.RuneRange{Min: 0x41, Max: 0x46}, op.RuneRange{Min: 0x61, Max: 0x66}}
	ESC          = rune(0x5C)
)

func NewParser(input []rune) (*parser.Parser, error) {
	p, err := parser.New(input)
	if err != nil {
		return nil, err
	}
	p.Rules["Value"] = Value
	return p, nil
}

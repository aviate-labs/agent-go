// Do NOT edit this file. It was automatically generated by https://github.com/aviate-labs/agent-go.
package assetstorage_test

import (
	"github.com/aviate-labs/agent-go"
	"github.com/aviate-labs/agent-go/candid/idl"
	"github.com/aviate-labs/agent-go/mock"
	"github.com/aviate-labs/agent-go/principal"
	"net/http/httptest"
	"net/url"
	"testing"

	"github.com/aviate-labs/agent-go/ic/assetstorage"
)

// Test_ApiVersion tests the "api_version" method on the "assetstorage" canister.
func Test_ApiVersion(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "api_version",
			Arguments: []any{},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new(uint16)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	if _, err := a.ApiVersion(); err != nil {
		t.Fatal(err)
	}

}

// Test_Authorize tests the "authorize" method on the "assetstorage" canister.
func Test_Authorize(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "authorize",
			Arguments: []any{new(principal.Principal)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = *new(principal.Principal)
	if err := a.Authorize(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CertifiedTree tests the "certified_tree" method on the "assetstorage" canister.
func Test_CertifiedTree(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name: "certified_tree",
			Arguments: []any{new(struct {
			})},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{struct {
					Certificate []byte `ic:"certificate" json:"certificate"`
					Tree        []byte `ic:"tree" json:"tree"`
				}{
					*new([]byte),
					*new([]byte),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = struct {
	}{}
	if _, err := a.CertifiedTree(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_Clear tests the "clear" method on the "assetstorage" canister.
func Test_Clear(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "clear",
			Arguments: []any{new(assetstorage.ClearArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.ClearArguments{}
	if err := a.Clear(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CommitBatch tests the "commit_batch" method on the "assetstorage" canister.
func Test_CommitBatch(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "commit_batch",
			Arguments: []any{new(assetstorage.CommitBatchArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.CommitBatchArguments{
		idl.NewNat(uint(0)),
		[]assetstorage.BatchOperationKind{{
			CreateAsset: idl.Ptr(assetstorage.CreateAssetArguments{
				*new(string),
				*new(string),
				*new(*uint64),
				*new(*[]assetstorage.HeaderField),
				*new(*bool),
				*new(*bool),
			}),
		}},
	}
	if err := a.CommitBatch(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CommitProposedBatch tests the "commit_proposed_batch" method on the "assetstorage" canister.
func Test_CommitProposedBatch(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "commit_proposed_batch",
			Arguments: []any{new(assetstorage.CommitProposedBatchArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.CommitProposedBatchArguments{
		idl.NewNat(uint(0)),
		*new([]byte),
	}
	if err := a.CommitProposedBatch(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ComputeEvidence tests the "compute_evidence" method on the "assetstorage" canister.
func Test_ComputeEvidence(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "compute_evidence",
			Arguments: []any{new(assetstorage.ComputeEvidenceArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new(*[]byte)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.ComputeEvidenceArguments{
		idl.NewNat(uint(0)),
		*new(*uint16),
	}
	if _, err := a.ComputeEvidence(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_Configure tests the "configure" method on the "assetstorage" canister.
func Test_Configure(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "configure",
			Arguments: []any{new(assetstorage.ConfigureArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.ConfigureArguments{
		*new(**uint64),
		*new(**uint64),
		*new(**uint64),
	}
	if err := a.Configure(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CreateAsset tests the "create_asset" method on the "assetstorage" canister.
func Test_CreateAsset(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "create_asset",
			Arguments: []any{new(assetstorage.CreateAssetArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.CreateAssetArguments{
		*new(string),
		*new(string),
		*new(*uint64),
		*new(*[]assetstorage.HeaderField),
		*new(*bool),
		*new(*bool),
	}
	if err := a.CreateAsset(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CreateBatch tests the "create_batch" method on the "assetstorage" canister.
func Test_CreateBatch(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name: "create_batch",
			Arguments: []any{new(struct {
			})},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{struct {
					BatchId assetstorage.BatchId `ic:"batch_id" json:"batch_id"`
				}{
					idl.NewNat(uint(0)),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = struct {
	}{}
	if _, err := a.CreateBatch(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CreateChunk tests the "create_chunk" method on the "assetstorage" canister.
func Test_CreateChunk(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name: "create_chunk",
			Arguments: []any{new(struct {
				BatchId assetstorage.BatchId `ic:"batch_id" json:"batch_id"`
				Content []byte               `ic:"content" json:"content"`
			})},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{struct {
					ChunkId assetstorage.ChunkId `ic:"chunk_id" json:"chunk_id"`
				}{
					idl.NewNat(uint(0)),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = struct {
		BatchId assetstorage.BatchId `ic:"batch_id" json:"batch_id"`
		Content []byte               `ic:"content" json:"content"`
	}{
		idl.NewNat(uint(0)),
		*new([]byte),
	}
	if _, err := a.CreateChunk(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_Deauthorize tests the "deauthorize" method on the "assetstorage" canister.
func Test_Deauthorize(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "deauthorize",
			Arguments: []any{new(principal.Principal)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = *new(principal.Principal)
	if err := a.Deauthorize(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_DeleteAsset tests the "delete_asset" method on the "assetstorage" canister.
func Test_DeleteAsset(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "delete_asset",
			Arguments: []any{new(assetstorage.DeleteAssetArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.DeleteAssetArguments{
		*new(string),
	}
	if err := a.DeleteAsset(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_DeleteBatch tests the "delete_batch" method on the "assetstorage" canister.
func Test_DeleteBatch(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "delete_batch",
			Arguments: []any{new(assetstorage.DeleteBatchArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.DeleteBatchArguments{
		idl.NewNat(uint(0)),
	}
	if err := a.DeleteBatch(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_Get tests the "get" method on the "assetstorage" canister.
func Test_Get(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name: "get",
			Arguments: []any{new(struct {
				Key             assetstorage.Key `ic:"key" json:"key"`
				AcceptEncodings []string         `ic:"accept_encodings" json:"accept_encodings"`
			})},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{struct {
					Content         []byte  `ic:"content" json:"content"`
					ContentType     string  `ic:"content_type" json:"content_type"`
					ContentEncoding string  `ic:"content_encoding" json:"content_encoding"`
					Sha256          *[]byte `ic:"sha256,omitempty" json:"sha256,omitempty"`
					TotalLength     idl.Nat `ic:"total_length" json:"total_length"`
				}{
					*new([]byte),
					*new(string),
					*new(string),
					*new(*[]byte),
					idl.NewNat(uint(0)),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = struct {
		Key             assetstorage.Key `ic:"key" json:"key"`
		AcceptEncodings []string         `ic:"accept_encodings" json:"accept_encodings"`
	}{
		*new(string),
		[]string{*new(string)},
	}
	if _, err := a.Get(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_GetAssetProperties tests the "get_asset_properties" method on the "assetstorage" canister.
func Test_GetAssetProperties(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "get_asset_properties",
			Arguments: []any{new(assetstorage.Key)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{struct {
					MaxAge         *uint64                     `ic:"max_age,omitempty" json:"max_age,omitempty"`
					Headers        *[]assetstorage.HeaderField `ic:"headers,omitempty" json:"headers,omitempty"`
					AllowRawAccess *bool                       `ic:"allow_raw_access,omitempty" json:"allow_raw_access,omitempty"`
					IsAliased      *bool                       `ic:"is_aliased,omitempty" json:"is_aliased,omitempty"`
				}{
					*new(*uint64),
					*new(*[]assetstorage.HeaderField),
					*new(*bool),
					*new(*bool),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = *new(string)
	if _, err := a.GetAssetProperties(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_GetChunk tests the "get_chunk" method on the "assetstorage" canister.
func Test_GetChunk(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name: "get_chunk",
			Arguments: []any{new(struct {
				Key             assetstorage.Key `ic:"key" json:"key"`
				ContentEncoding string           `ic:"content_encoding" json:"content_encoding"`
				Index           idl.Nat          `ic:"index" json:"index"`
				Sha256          *[]byte          `ic:"sha256,omitempty" json:"sha256,omitempty"`
			})},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{struct {
					Content []byte `ic:"content" json:"content"`
				}{
					*new([]byte),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = struct {
		Key             assetstorage.Key `ic:"key" json:"key"`
		ContentEncoding string           `ic:"content_encoding" json:"content_encoding"`
		Index           idl.Nat          `ic:"index" json:"index"`
		Sha256          *[]byte          `ic:"sha256,omitempty" json:"sha256,omitempty"`
	}{
		*new(string),
		*new(string),
		idl.NewNat(uint(0)),
		*new(*[]byte),
	}
	if _, err := a.GetChunk(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_GetConfiguration tests the "get_configuration" method on the "assetstorage" canister.
func Test_GetConfiguration(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "get_configuration",
			Arguments: []any{},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{assetstorage.ConfigurationResponse{
					*new(*uint64),
					*new(*uint64),
					*new(*uint64),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	if _, err := a.GetConfiguration(); err != nil {
		t.Fatal(err)
	}

}

// Test_GrantPermission tests the "grant_permission" method on the "assetstorage" canister.
func Test_GrantPermission(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "grant_permission",
			Arguments: []any{new(assetstorage.GrantPermission)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.GrantPermission{
		*new(principal.Principal),
		assetstorage.Permission{
			Commit: new(idl.Null),
		},
	}
	if err := a.GrantPermission(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_HttpRequest tests the "http_request" method on the "assetstorage" canister.
func Test_HttpRequest(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "http_request",
			Arguments: []any{new(assetstorage.HttpRequest)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{assetstorage.HttpResponse{
					*new(uint16),
					[]assetstorage.HeaderField{{
						*new(string),
						*new(string),
					}},
					*new([]byte),
					*new(*assetstorage.StreamingStrategy),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.HttpRequest{
		*new(string),
		*new(string),
		[]assetstorage.HeaderField{{
			*new(string),
			*new(string),
		}},
		*new([]byte),
		*new(*uint16),
	}
	if _, err := a.HttpRequest(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_HttpRequestStreamingCallback tests the "http_request_streaming_callback" method on the "assetstorage" canister.
func Test_HttpRequestStreamingCallback(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "http_request_streaming_callback",
			Arguments: []any{new(assetstorage.StreamingCallbackToken)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new(*assetstorage.StreamingCallbackHttpResponse)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.StreamingCallbackToken{
		*new(string),
		*new(string),
		idl.NewNat(uint(0)),
		*new(*[]byte),
	}
	if _, err := a.HttpRequestStreamingCallback(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_List tests the "list" method on the "assetstorage" canister.
func Test_List(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name: "list",
			Arguments: []any{new(struct {
			})},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{[]struct {
					Key         assetstorage.Key `ic:"key" json:"key"`
					ContentType string           `ic:"content_type" json:"content_type"`
					Encodings   []struct {
						ContentEncoding string            `ic:"content_encoding" json:"content_encoding"`
						Sha256          *[]byte           `ic:"sha256,omitempty" json:"sha256,omitempty"`
						Length          idl.Nat           `ic:"length" json:"length"`
						Modified        assetstorage.Time `ic:"modified" json:"modified"`
					} `ic:"encodings" json:"encodings"`
				}{

					{
						*new(string),
						*new(string),
						[]struct {
							ContentEncoding string            `ic:"content_encoding" json:"content_encoding"`
							Sha256          *[]byte           `ic:"sha256,omitempty" json:"sha256,omitempty"`
							Length          idl.Nat           `ic:"length" json:"length"`
							Modified        assetstorage.Time `ic:"modified" json:"modified"`
						}{

							{
								*new(string),
								*new(*[]byte),
								idl.NewNat(uint(0)),
								idl.NewInt(0),
							}},
					}}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = struct {
	}{}
	if _, err := a.List(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ListAuthorized tests the "list_authorized" method on the "assetstorage" canister.
func Test_ListAuthorized(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "list_authorized",
			Arguments: []any{},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{[]principal.Principal{*new(principal.Principal)}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	if _, err := a.ListAuthorized(); err != nil {
		t.Fatal(err)
	}

}

// Test_ListPermitted tests the "list_permitted" method on the "assetstorage" canister.
func Test_ListPermitted(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "list_permitted",
			Arguments: []any{new(assetstorage.ListPermitted)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{[]principal.Principal{*new(principal.Principal)}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.ListPermitted{
		assetstorage.Permission{
			Commit: new(idl.Null),
		},
	}
	if _, err := a.ListPermitted(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ProposeCommitBatch tests the "propose_commit_batch" method on the "assetstorage" canister.
func Test_ProposeCommitBatch(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "propose_commit_batch",
			Arguments: []any{new(assetstorage.CommitBatchArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.CommitBatchArguments{
		idl.NewNat(uint(0)),
		[]assetstorage.BatchOperationKind{{
			CreateAsset: idl.Ptr(assetstorage.CreateAssetArguments{
				*new(string),
				*new(string),
				*new(*uint64),
				*new(*[]assetstorage.HeaderField),
				*new(*bool),
				*new(*bool),
			}),
		}},
	}
	if err := a.ProposeCommitBatch(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_RevokePermission tests the "revoke_permission" method on the "assetstorage" canister.
func Test_RevokePermission(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "revoke_permission",
			Arguments: []any{new(assetstorage.RevokePermission)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.RevokePermission{
		*new(principal.Principal),
		assetstorage.Permission{
			Commit: new(idl.Null),
		},
	}
	if err := a.RevokePermission(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_SetAssetContent tests the "set_asset_content" method on the "assetstorage" canister.
func Test_SetAssetContent(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "set_asset_content",
			Arguments: []any{new(assetstorage.SetAssetContentArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.SetAssetContentArguments{
		*new(string),
		*new(string),
		[]assetstorage.ChunkId{idl.NewNat(uint(0))},
		*new(*[]byte),
	}
	if err := a.SetAssetContent(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_SetAssetProperties tests the "set_asset_properties" method on the "assetstorage" canister.
func Test_SetAssetProperties(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "set_asset_properties",
			Arguments: []any{new(assetstorage.SetAssetPropertiesArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.SetAssetPropertiesArguments{
		*new(string),
		*new(**uint64),
		*new(**[]assetstorage.HeaderField),
		*new(**bool),
		*new(**bool),
	}
	if err := a.SetAssetProperties(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_Store tests the "store" method on the "assetstorage" canister.
func Test_Store(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name: "store",
			Arguments: []any{new(struct {
				Key             assetstorage.Key `ic:"key" json:"key"`
				ContentType     string           `ic:"content_type" json:"content_type"`
				ContentEncoding string           `ic:"content_encoding" json:"content_encoding"`
				Content         []byte           `ic:"content" json:"content"`
				Sha256          *[]byte          `ic:"sha256,omitempty" json:"sha256,omitempty"`
			})},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = struct {
		Key             assetstorage.Key `ic:"key" json:"key"`
		ContentType     string           `ic:"content_type" json:"content_type"`
		ContentEncoding string           `ic:"content_encoding" json:"content_encoding"`
		Content         []byte           `ic:"content" json:"content"`
		Sha256          *[]byte          `ic:"sha256,omitempty" json:"sha256,omitempty"`
	}{
		*new(string),
		*new(string),
		*new(string),
		*new([]byte),
		*new(*[]byte),
	}
	if err := a.Store(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_TakeOwnership tests the "take_ownership" method on the "assetstorage" canister.
func Test_TakeOwnership(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "take_ownership",
			Arguments: []any{},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	if err := a.TakeOwnership(); err != nil {
		t.Fatal(err)
	}

}

// Test_UnsetAssetContent tests the "unset_asset_content" method on the "assetstorage" canister.
func Test_UnsetAssetContent(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "unset_asset_content",
			Arguments: []any{new(assetstorage.UnsetAssetContentArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.UnsetAssetContentArguments{
		*new(string),
		*new(string),
	}
	if err := a.UnsetAssetContent(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ValidateCommitProposedBatch tests the "validate_commit_proposed_batch" method on the "assetstorage" canister.
func Test_ValidateCommitProposedBatch(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "validate_commit_proposed_batch",
			Arguments: []any{new(assetstorage.CommitProposedBatchArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{assetstorage.ValidationResult{
					Ok: new(string),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.CommitProposedBatchArguments{
		idl.NewNat(uint(0)),
		*new([]byte),
	}
	if _, err := a.ValidateCommitProposedBatch(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ValidateConfigure tests the "validate_configure" method on the "assetstorage" canister.
func Test_ValidateConfigure(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "validate_configure",
			Arguments: []any{new(assetstorage.ConfigureArguments)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{assetstorage.ValidationResult{
					Ok: new(string),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.ConfigureArguments{
		*new(**uint64),
		*new(**uint64),
		*new(**uint64),
	}
	if _, err := a.ValidateConfigure(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ValidateGrantPermission tests the "validate_grant_permission" method on the "assetstorage" canister.
func Test_ValidateGrantPermission(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "validate_grant_permission",
			Arguments: []any{new(assetstorage.GrantPermission)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{assetstorage.ValidationResult{
					Ok: new(string),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.GrantPermission{
		*new(principal.Principal),
		assetstorage.Permission{
			Commit: new(idl.Null),
		},
	}
	if _, err := a.ValidateGrantPermission(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ValidateRevokePermission tests the "validate_revoke_permission" method on the "assetstorage" canister.
func Test_ValidateRevokePermission(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "validate_revoke_permission",
			Arguments: []any{new(assetstorage.RevokePermission)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{assetstorage.ValidationResult{
					Ok: new(string),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = assetstorage.RevokePermission{
		*new(principal.Principal),
		assetstorage.Permission{
			Commit: new(idl.Null),
		},
	}
	if _, err := a.ValidateRevokePermission(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ValidateTakeOwnership tests the "validate_take_ownership" method on the "assetstorage" canister.
func Test_ValidateTakeOwnership(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "validate_take_ownership",
			Arguments: []any{},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{assetstorage.ValidationResult{
					Ok: new(string),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	if _, err := a.ValidateTakeOwnership(); err != nil {
		t.Fatal(err)
	}

}

// newAgent creates a new agent with the given (mock) methods.
// Runs a mock replica in the background.
func newAgent(methods []mock.Method) (*assetstorage.Agent, error) {
	replica := mock.NewReplica()
	canisterId := principal.Principal{Raw: []byte("assetstorage")}
	replica.AddCanister(canisterId, methods)
	s := httptest.NewServer(replica)
	u, _ := url.Parse(s.URL)
	a, err := assetstorage.NewAgent(canisterId, agent.Config{
		ClientConfig: &agent.ClientConfig{Host: u},
		FetchRootKey: true,
	})
	if err != nil {
		return nil, err
	}
	return a, nil
}
